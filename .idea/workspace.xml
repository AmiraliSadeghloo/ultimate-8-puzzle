<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="a3c64ead-faf8-42a8-b00f-cc45d9b5c608" name="Default Changelist" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ProjectId" id="1ddj0E2EgjReWy0P2fwOFAjzlxt" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
  </component>
  <component name="ReplState" timestamp="1592775630453">{:repl-history {:ide [], :local [{:command &quot;(defn find-curr [unchecked]\n  (reduce (fn [max-map each]\n            (if (&lt; (+ (:a max-map) (:b max-map)) (+ (:a each) (:b each)))\n              max-map))\n          (first unchecked) (rest unchecked)))\n;;/////////////////////\n(defn moves-to-unchecked [unchecked movements]                  ;this will recur to unchecked each time\n  (let [legal-moves (filter #(not= false %) movements)]\n    (reduce (fn [a b] (conj a b)) unchecked legal-moves)))\n;(moves-to-unchecked [{:a 1} {:b 2}] [{:c 3} false {:d 4}])&quot;, :offset 504, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(def goal [[1 2 3] [4 5 6] [7 8 0]])\n(defn swap-right                                            ;;ok if reaches border/ puts nil\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [i1 (+ 1 j1)]))\n        s (assoc-in q [i1 (+ 1 j1)] f)]\n    s))\n\n(defn swap-left\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [i1 (- j1 1)]))\n        s (assoc-in q [i1 (- j1 1)] f)]\n    s))\n\n(defn swap-down\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [(+ i1 1) j1]))\n        s (assoc-in q [(+ 1 i1) j1] f)]\n    s))\n\n(defn swap-up\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [(- i1 1) j1]))\n        s (assoc-in q [(- i1 1) j1] f)]\n    s))\n;;/////////////////\n(defn zero-finder                                           ;;finds zero in 3*3 vector\n  [input]\n  {:zero (first (for [i (range 3)\n                      j (range 3)\n                      :when (= 0 (get-in input [i j]))]\n                  [i j]\n                  ))})\n;;///////////////\n(defn h-cost [v]                                            ;\n  (let [v-flat (into [] (flatten v))\n        goal-flat (into [] (flatten goal))]\n    (- (count goal-flat) (loop [counted 0 [next1 &amp; rest1] v-flat [next2 &amp; rest2] goal-flat]\n                           (if-not (and next1 next2)\n                             counted\n                             (if (= next2 next1)\n                               (recur (inc counted) rest1 rest2)\n                               (recur counted rest1 rest2)))))))\n;(h-cost [[1 2 3] [4 5 6] [7 0 8]])\n;/////////////////\n(defn mapped-input [init]\n  {:vector init :history [] :h (h-cost init)})\n;;///////////////////\n(defn move-reversed [move]\n  (case move\n    :up :down\n    :right :left\n    :left :right\n    :down :up\n    nil))\n;;////////////////\n(defn movements                                             ;;creates all 4 directions.\n  [current]                                                 ;; checked for legal moves in moves-to-unchecked\n  (let [zero (:zero (zero-finder current))]\n    [(if (or (not= :right (move-reversed (last (:history current)))) (= 2 (second zero)))\n       false\n       {:vector  (swap-right current zero)\n        :history (conj (:history current) :right)\n        :h       (h-cost (swap-right current zero))})\n\n     (if (or (not= :left (move-reversed (last (:history current)))) (= 0 (second zero)))\n       false\n       {:vector  (swap-left current zero)\n        :history (conj (:history current) :left)\n        :h       (h-cost (swap-left current zero))})\n\n     (if (or (not= :down (move-reversed (last (:history current)))) (= 2 (first zero)))\n       false\n       {:vector  (swap-down current zero)\n        :history (conj (:history current) :down)\n        :h       (h-cost (swap-down current zero))})\n\n     (if (or (not= :up (move-reversed (last (:history current)))) (= 0 (first zero)))\n       false\n       {:vector  (swap-up current zero)\n        :history (conj (:history current) :up)\n        :h       (h-cost (swap-up current zero))})]))&quot;, :offset 3082, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn solvable? [x]                                         ;;fix 0 to empty\n  (let [flattened-removed-empty (into [] (filter #(not= 0 %) (into [] (flatten x))))]\n    (loop [counts [] xs flattened-removed-empty]\n      (if (seq xs)\n        (let [head (first xs)\n              tail (rest xs)\n              counter (fn [xi xj] (if (&gt; xj head) (inc xi) xi))]\n          (recur (conj counts (reduce counter\n                                      0\n                                      tail)) tail))\n        (even? (reduce + counts))))))&quot;, :offset 530, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(ns finaleightpuzzle.core\n(:use [finaleightpuzzle.node]\n      [finaleightpuzzle.vector])\n  (:gen-class))&quot;, :offset 104, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (mapped-input init))&quot;, :offset 40, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [7 8 9]])&quot;, :offset 32, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;[(mapped-input init)]&quot;, :offset 21, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(mapped-input init)&quot;, :offset 19, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn find-curr [unchecked]\n  (reduce (fn [max-map each]\n            (if (&lt; (+ (count (:history max-map)) (:h max-map)) \n                   (+ (count (:history each)) (:h each)))\n              max-map))\n          (first unchecked) (rest unchecked)))&quot;, :offset 249, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (do\n      (loop [unchecked (into [] (mapped-input init)) checked []]\n        (let [curr (find-curr unchecked)]\n          (if (= 0 (h-cost curr))\n            (:history curr)\n            (do\n              (recur (moves-to-unchecked unchecked (movements curr)) (conj checked curr)))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 376, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(into [] (mapped-input [[1 2 3] [4 5 6] [7 8 9]]))&quot;, :offset 50, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(mapped-input [[1 2 3] [4 5 6] [7 8 9]])&quot;, :offset 40, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(reduce into [] (mapped-input [[1 2 3] [4 5 6] [7 8 9]]))&quot;, :offset 57, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(conj [] (mapped-input [[1 2 3] [4 5 6] [7 8 9]]))&quot;, :offset 50, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (do\n      (loop [unchecked (conj [] (mapped-input init)) checked []]\n        (let [curr (find-curr unchecked)]\n          (if (= 0 (h-cost curr))\n            (:history curr)\n            (do\n              (recur (moves-to-unchecked unchecked (movements curr)) (conj checked curr)))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 376, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [0 7 8]])&quot;, :offset 32, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(do\n  (println \&quot;hi\&quot;))&quot;, :offset 21, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn remove-current [unchecked curr]\n  (into [] (remove #(= curr %) unchecked)))&quot;, :offset 81, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (do\n      (loop [unchecked (conj [] (mapped-input init)) checked []]\n        (let [curr (find-curr unchecked)]\n          (if (= 0 (h-cost curr))\n            (:history curr)\n            (do\n              (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                     (conj checked curr)))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 419, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [8 7 0]])&quot;, :offset 32, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;\&quot;hi\&quot;&quot;, :offset 4, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(do \n  (println \&quot;hi\&quot;))&quot;, :offset 22, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(do \n  (+ 2 1)\n  (println \&quot;hi\&quot;))&quot;, :offset 32, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(+ 2 1)&quot;, :offset 7, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (= 0 (h-cost curr))\n          (:history curr)\n          (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr))))))\n  (throw (Exception. \&quot;not solvable input\&quot;)))&quot;, :offset 375, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(conj [{:a 1} {:b 2}] {:c 3})&quot;, :offset 29, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(solvable? [[1 2 3] [4 5 6] [7 0 8]])&quot;, :offset 37, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n  (throw (Exception. \&quot;not solvable input\&quot;)))&quot;, :offset 401, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i)))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 403, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            (println \&quot;next unchecked: \&quot; unchecked)\n            (println \&quot;next curr: \&quot; curr)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 512, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(remove-current [{:a 1 :b 2} {:c 3 :d 4}] {:a 1 :b 2})&quot;, :offset 54, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(remove-current [{:a 1 :b 2} {:c 3 :d 4} {:e 5 :f 6}] {:a 1 :b 2})&quot;, :offset 66, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(remove-current [{:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2}] {:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2}  )\n&quot;, :offset 131, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn movements                                             ;;creates all 4 directions.\n  [current]                                                 ;; checked for legal moves in moves-to-unchecked\n  (let [zero (:zero (zero-finder (:vector current)))]\n    [(if (or (not= :right (move-reversed (last (:history current)))) (= 2 (second zero)))\n       false\n       {:vector  (swap-right current zero)\n        :history (conj (:history current) :right)\n        :h       (h-cost (swap-right current zero))})\n\n     (if (or (not= :left (move-reversed (last (:history current)))) (= 0 (second zero)))\n       false\n       {:vector  (swap-left current zero)\n        :history (conj (:history current) :left)\n        :h       (h-cost (swap-left current zero))})\n\n     (if (or (not= :down (move-reversed (last (:history current)))) (= 2 (first zero)))\n       false\n       {:vector  (swap-down current zero)\n        :history (conj (:history current) :down)\n        :h       (h-cost (swap-down current zero))})\n\n     (if (or (not= :up (move-reversed (last (:history current)))) (= 0 (first zero)))\n       false\n       {:vector  (swap-up current zero)\n        :history (conj (:history current) :up)\n        :h       (h-cost (swap-up current zero))})]))&quot;, :offset 1234, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(:zero (zero-finder (:vector {:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2})))&quot;, :offset 86, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn movements                                             ;;creates all 4 directions.\n  [current]                                                 ;; checked for legal moves in moves-to-unchecked\n  (let [zero (:zero (zero-finder (:vector current)))]\n    [(if (or (= :right (move-reversed (last (:history current)))) (= 2 (second zero)))\n       false\n       {:vector  (swap-right current zero)\n        :history (conj (:history current) :right)\n        :h       (h-cost (swap-right current zero))})\n\n     (if (or (= :left (move-reversed (last (:history current)))) (= 0 (second zero)))\n       false\n       {:vector  (swap-left current zero)\n        :history (conj (:history current) :left)\n        :h       (h-cost (swap-left current zero))})\n\n     (if (or (= :down (move-reversed (last (:history current)))) (= 2 (first zero)))\n       false\n       {:vector  (swap-down current zero)\n        :history (conj (:history current) :down)\n        :h       (h-cost (swap-down current zero))})\n\n     (if (or (= :up (move-reversed (last (:history current)))) (= 0 (first zero)))\n       false\n       {:vector  (swap-up current zero)\n        :history (conj (:history current) :up)\n        :h       (h-cost (swap-up current zero))})]))&quot;, :offset 1222, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            (println \&quot;next unchecked: \&quot; unchecked)\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 624, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 619, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 741, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(movements {:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2})&quot;, :offset 66, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn movements                                             ;;creates all 4 directions.\n  [current]                                                 ;; checked for legal moves in moves-to-unchecked\n  (let [zero (:zero (zero-finder (:vector current)))]\n    [(if (or (= :right (move-reversed (last (:history current)))) (= 2 (second zero)))\n       false\n       {:vector  (swap-right (:vector current) zero)\n        :history (conj (:history current) :right)\n        :h       (h-cost (swap-right current zero))})\n\n     (if (or (= :left (move-reversed (last (:history current)))) (= 0 (second zero)))\n       false\n       {:vector  (swap-left (:vector current) zero)\n        :history (conj (:history current) :left)\n        :h       (h-cost (swap-left current zero))})\n\n     (if (or (= :down (move-reversed (last (:history current)))) (= 2 (first zero)))\n       false\n       {:vector  (swap-down (:vector current) zero)\n        :history (conj (:history current) :down)\n        :h       (h-cost (swap-down current zero))})\n\n     (if (or (= :up (move-reversed (last (:history current)))) (= 0 (first zero)))\n       false\n       {:vector  (swap-up (:vector current) zero)\n        :history (conj (:history current) :up)\n        :h       (h-cost (swap-up current zero))})]))&quot;, :offset 1262, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9}])&quot;, :offset 48, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9} {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 89, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9} {:vector 0 :history [:right] :h 7} {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 124, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn find-curr [unchecked]\n  (let [x (reduce (fn [max-map each]\n            (if (&lt; (+ (count (:history max-map)) (:h max-map))\n                   (+ (count (:history each)) (:h each)))\n              max-map))\n          (first unchecked) (rest unchecked))]\n    x))&quot;, :offset 264, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9} {:vector 0 :history [:right] :h 5} {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 124, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9}\n            {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 101, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right] :h 9}\n            {:vector 0 :history [:right] :h 5}\n            {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 148, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right :left] :h 9}\n            {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 107, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn find-curr [unchecked]\n  (let [x (reduce (fn [max-map each]\n            (if (&lt; (+ (count (:history max-map)) (:h max-map))\n                   (+ (count (:history each)) (:h each)))\n              max-map\n              each))\n          (first unchecked) (rest unchecked))]\n    x))&quot;, :offset 283, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right :left] :h 9}\n            {:vector 0 :history [:right] :h 5}\n            {:vector 0 :history [:right :left] :h 9}])&quot;, :offset 154, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right :left] :h 9}\n            {:vector 0 :history [:right] :h 5}])&quot;, :offset 101, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector 0 :history [:right :left] :h 9}\n            {:vector 0 :history [:right] :h 5}\n            {:vector 0 :history [:right :left] :h 5}])&quot;, :offset 154, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 1000 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 748, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 2000 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 748, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 10000 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)) )\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 749, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(find-curr [{:vector [[1 2 3] [4 5 6] [7 8 0]], :history [:right], :h 10} {:vector [[1 2 3] [4 5 6] [0 7 8]], :history [:left], :h 12} {:vector [[1 2 3] [4 0 6] [7 5 8]], :history [:up], :h 9}])\n&quot;, :offset 195, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 5 i) (= 0 (h-cost curr)))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 790, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(h-cost [[1 2 3] [4 5 6] [7 8 0]])&quot;, :offset 34, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [7 0 8]] [2 1] )&quot;, :offset 45, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(:zero (zero-finder [[1 2 3] [4 5 6] [7 0 8]]))&quot;, :offset 47, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [7 0 8]] (:zero (zero-finder [[1 2 3] [4 5 6] [7 0 8]])) )&quot;, :offset 87, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(h-cost(swap-right [[1 2 3] [4 5 6] [7 0 8]] (:zero (zero-finder [[1 2 3] [4 5 6] [7 0 8]]))))&quot;, :offset 94, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn movements                                             ;;creates all 4 directions.\n  [current]                                                 ;; checked for legal moves in moves-to-unchecked\n  (let [zero (:zero (zero-finder (:vector current)))]\n    [(if (or (= :right (move-reversed (last (:history current)))) (= 2 (second zero)))\n       false\n       {:vector  (swap-right (:vector current) zero)\n        :history (conj (:history current) :right)\n        :h       (h-cost (swap-right (:vector current) zero))})\n\n     (if (or (= :left (move-reversed (last (:history current)))) (= 0 (second zero)))\n       false\n       {:vector  (swap-left (:vector current) zero)\n        :history (conj (:history current) :left)\n        :h       (h-cost (swap-left (:vector current) zero))})\n\n     (if (or (= :down (move-reversed (last (:history current)))) (= 2 (first zero)))\n       false\n       {:vector  (swap-down (:vector current) zero)\n        :history (conj (:history current) :down)\n        :h       (h-cost (swap-down (:vector current) zero))})\n\n     (if (or (= :up (move-reversed (last (:history current)))) (= 0 (first zero)))\n       false\n       {:vector  (swap-up (:vector current) zero)\n        :history (conj (:history current) :up)\n        :h       (h-cost (swap-up (:vector current) zero))})]))&quot;, :offset 1302, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn find-curr [unchecked]                                 ;;fixed\n  (let [x (reduce (fn [max-map each]\n            (if (&lt; (+ (count (:history max-map)) (:h max-map))\n                   (+ (count (:history each)) (:h each)))\n              max-map\n              each))\n          (first unchecked) (rest unchecked))]\n    x))&quot;, :offset 323, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector [[1 2 3] [4 5 6] [7 8 0]], :history [:right], :h 9} {:vector [[1 2 3] [4 5 6] [0 7 8]], :history [:left], :h 9} {:vector [[1 2 3] [4 0 6] [7 5 8]], :history [:up], :h 9}])\n&quot;, :offset 193, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn find-curr [unchecked]\n  (reduce (fn [min-map each]\n            (if (= (+ (count (:history min-map)) (:h min-map))\n                   (+ (count (:history unchecked)) (:h unchecked)))\n              (if (&lt; (:h min-map) (:h unchecked))\n                min-map\n                unchecked)\n              (if (&lt; (+ (count (:history min-map)) (:h min-map))\n                     (+ (count (:history each)) (:h each)))\n                min-map\n                each)))\n          (first unchecked) (rest unchecked)))&quot;, :offset 508, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2}] )&quot;, :offset 69, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn find-curr [unchecked]\n  (reduce (fn [min-map each]\n            (if (= (+ (count (:history min-map)) (:h min-map))\n                   (+ (count (:history unchecked)) (:h unchecked)))\n              (if (&lt; (:h min-map) (:h unchecked))\n                min-map\n                each)\n              (if (&lt; (+ (count (:history min-map)) (:h min-map))\n                     (+ (count (:history each)) (:h each)))\n                min-map\n                each)))\n          (first unchecked) (rest unchecked)))&quot;, :offset 503, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn find-curr [unchecked]\n  (reduce (fn [min-map each]\n            (if (= (+ (count (:history min-map)) (:h min-map))\n                   (+ (count (:history each)) (:h each)))\n              (if (&lt; (:h min-map) (:h each))\n                min-map\n                each)\n              (if (&lt; (+ (count (:history min-map)) (:h min-map))\n                     (+ (count (:history each)) (:h each)))\n                min-map\n                each)))\n          (first unchecked) (rest unchecked)))&quot;, :offset 488, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector [[1 2 3] [4 5 6] [7 0 8]], :history [], :h 2}])&quot;, :offset 68, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(find-curr [{:vector [[1 2 3] [4 5 6] [7 8 0]], :history [:right], :h 0} {:vector [[1 2 3] [4 5 6] [0 7 8]], :history [:left], :h 3} {:vector [[1 2 3] [4 0 6] [7 5 8]], :history [:up], :h 3}])\n&quot;, :offset 193, :ns &quot;finaleightpuzzle.node&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 5 i) (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 800, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 100 i) (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 802, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 1000 i) (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 803, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [7 0 8]])&quot;, :offset 32, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked [] i 0]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 2000 i) (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            ;(println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                 (conj checked curr) (inc i))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 809, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[2 3 4]\n       [1 5 0]\n       [7 6 8]])&quot;, :offset 46, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(:zero (zero-finder [[1 2 3] [4 5 6] [7 :empty 8]]))&quot;, :offset 52, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [ i 0 unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 5 i)\n                (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            ;(println \&quot;==========================\&quot;)\n            (recur (inc i) (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                   (conj checked curr))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 825, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [ i 0 unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (or (= 5 i)\n                (= 0 (h-cost (:vector curr))))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (inc i) (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                   (conj checked curr))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 819, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(def goal [[1 2 3] [4 5 6] [7 8 :empty]])&quot;, :offset 41, :ns &quot;finaleightpuzzle.vector&quot;} {:command &quot;(ns finaleightpuzzle.core\n  (:use [finaleightpuzzle.node]\n        [finaleightpuzzle.vector])\n  (:gen-class))&quot;, :offset 108, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [i 0 unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (= 0 (h-cost (:vector curr)))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            ;(println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                   (conj checked curr))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 787, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[2 3 4]\n       [1 5 0]\n       [7 6 8]])\n&quot;, :offset 47, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (= 0 (h-cost (:vector curr)))\n          (:history curr)\n          (do\n            ;(println \&quot;next curr: \&quot; curr)\n            ;(println \&quot;unchecked: \&quot; unchecked)\n            ;(println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            ;(println \&quot;moves\&quot; (movements curr))\n            ;(println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            ;(println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                   (conj checked curr))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 783, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(defn main [init]                                           ;;main \n  (if (solvable? init)\n    (loop [unchecked (conj [] (mapped-input init)) checked []]\n      (let [curr (find-curr unchecked)]\n        (if (= 0 (h-cost (:vector curr)))\n          (:history curr)\n          (do\n            (println \&quot;next curr: \&quot; curr)\n            (println \&quot;unchecked: \&quot; unchecked)\n            (println \&quot;checked: \&quot; checked)\n            (println \&quot;removed unchecked\&quot; (remove-current unchecked curr) )\n            (println \&quot;moves\&quot; (movements curr))\n            (println \&quot;next unchecked: \&quot; (moves-to-unchecked (remove-current unchecked curr) (movements curr)))\n            (println \&quot;==========================\&quot;)\n            (recur (moves-to-unchecked (remove-current unchecked curr) (movements curr))\n                   (conj checked curr))))))\n    (throw (Exception. \&quot;not solvable input\&quot;))))&quot;, :offset 869, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [7 :empty 8]])&quot;, :offset 37, :ns &quot;finaleightpuzzle.core&quot;} {:command &quot;(main [[2 3 4]\n       [1 5 :empty]\n       [7 6 8]])&quot;, :offset 51, :ns &quot;finaleightpuzzle.core&quot;}], :remote []}}</component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration name="puzzleREPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="finaleightpuzzle" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="a3c64ead-faf8-42a8-b00f-cc45d9b5c608" name="Default Changelist" comment="" />
      <created>1592761638336</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1592761638336</updated>
      <workItem from="1592761641500" duration="12676000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="WindowStateProjectService">
    <state x="414" y="175" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1592761823106">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state x="414" y="175" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.0.1920.1040@0.0.1920.1040" timestamp="1592761823106" />
  </component>
</project>